$ComixWall: patch-p3scan_c,v 1.6 2016/07/12 10:30:10 soner Exp $
--- p3scan.c.orig	Mon Dec 12 17:00:00 2005
+++ p3scan.c	Tue Jul 12 12:45:39 2016
@@ -44,33 +44,36 @@ TODO: Wanted: no iptables support
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
+#include <signal.h>
+#include <assert.h>
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <sys/time.h>
+#include <sys/param.h>
+#include <sys/signal.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <net/pfvar.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <stdarg.h>
-#include <sys/signal.h>
-#include <sys/wait.h>
 #include <pwd.h>
 #include <time.h>
-#include <sys/time.h>
 #include <syslog.h>
-#include <sys/param.h>
 #include <ctype.h>
-#include <linux/netfilter_ipv4.h>
-#include <malloc.h>
 #include <getopt.h>
 #include <netdb.h>
 #include <libgen.h>
 #include <errno.h>
 #include <dirent.h>
-#include <sys/statvfs.h>
-#include <assert.h>
-#include <sys/select.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
 
 #include "p3scan.h"
 #include "getline_ssl.h"
@@ -105,6 +108,13 @@ extern int filecount;
 extern int MIMEH_set_outputdir(char *);
 #endif
 
+u_int32_t read_address(const char *s)
+{
+	int a, b, c, d;
+	sscanf(s, "%i.%i.%i.%i", &a, &b, &c, &d);
+	return htonl(a << 24 | b << 16 | c << 8 | d);
+}
+
 static int sockfd; /* has to be global, do_sigterm_main() want's to close them */
 
 /* the proxycontext is global for do_sigterm_proxy().
@@ -152,7 +162,7 @@ void do_log(int level, const char *fmt,...){
    if (!config->debug && config->quiet && level==LOG_NOTICE) return;
    va_start(az,fmt);
    vsnprintf(puffer, 4000, fmt, az);
-   strcpy(timenow,ctime(&now)+ 11);
+   strlcpy(timenow,ctime(&now)+ 11, sizeof(timenow));
    if (!config->debug){
      openlog(config->syslogname, LOGOPT, LOGFAC);
      syslog(LOG_NOTICE, "%s\n", puffer);
@@ -401,7 +411,7 @@ char *right(char *string, size_t i){
 
    if (i > strlength) i = strlength;
    buf = stralloc(i);
-   strcpy(buf, &string[strlength-i]);
+   strlcpy(buf, &string[strlength-i], i);
    return buf;
 }
 
@@ -699,7 +709,7 @@ int scan_mailfile(struct proxycontext *p){
 #define COPYMSG "/var/spool/p3scan/copymsg "
    FILE * scanner;
    static char  line[4096*16];
-   struct statvfs fs;
+   struct statfs fs;
    int htmlfd=0;
 
    ret=checktimeout(p);
@@ -720,7 +730,7 @@ int scan_mailfile(struct proxycontext *p){
    what the user determines is enough room in p3scan.conf
    This was already done... but it is also dynamic so check again.
    */
-   if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+   if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
       p->errmsg=1;
       context_uninit(p);
       config->emergency="Unable to get available space!";
@@ -1583,6 +1593,31 @@ int proxy(struct proxycontext *p){
    p->usessl=0;
 
    p->server_addr.sin_family = AF_INET;
+
+   int dev;
+   struct pfioc_natlook nl;
+
+   dev = open("/dev/pf", O_RDONLY);
+   if (dev == -1) {
+      do_log(LOG_NOTICE, "open dev pf failed");
+      return -1;
+   }
+  
+   memset(&nl, 0, sizeof(struct pfioc_natlook));
+   nl.saddr.v4.s_addr      = p->client_addr.sin_addr.s_addr;
+   nl.sport                = p->client_addr.sin_port;
+   nl.daddr.v4.s_addr      = read_address("127.0.0.1");
+   nl.dport                = htons(atoi("8110"));
+   nl.af                   = AF_INET;
+   nl.proto                = IPPROTO_TCP;
+   nl.direction            = PF_OUT;
+
+   if (ioctl(dev, DIOCNATLOOK, &nl)) ;
+
+   p->server_addr.sin_addr.s_addr = nl.rdaddr.v4.s_addr;
+   p->server_addr.sin_port = nl.rdport;
+   close(dev);
+
    /*
    // For testing:
    do_log(LOG_DEBUG,"Going to emergency mode...");
@@ -1619,13 +1654,7 @@ int proxy(struct proxycontext *p){
                p->dspamuser=strdup(substr(p->clientbuf->line,5,loc-5));
                p->actsvr=strdup(substr(p->clientbuf->line,loc+1,loc2-loc-1));
                p->actport=atoi(strdup(substr(p->clientbuf->line,loc2+1,len-loc2)));
-               p->server_addr.sin_port=htons(p->actport);
                p->server_host=gethostbyname(p->actsvr);
-               if (p->server_host){
-                  memcpy(&p->server_addr.sin_addr.s_addr, p->server_host->h_addr_list[0], p->server_host->h_length);
-               } else {
-                  p->server_addr.sin_addr.s_addr = inet_addr(p->actsvr);
-               }
                p->clientbuf->linelen=GETLINE_LINE_NULL;
                break;
             } else {
@@ -1640,10 +1669,6 @@ int proxy(struct proxycontext *p){
       }
    } else {
       if (htonl(INADDR_ANY) == config->targetaddr.sin_addr.s_addr) {
-         if (getsockopt(p->client_fd, SOL_IP, SO_ORIGINAL_DST, &p->server_addr, &p->socksize)){
-            do_log(LOG_CRIT, "ERR: No IP-Conntrack-data (getsockopt failed)");
-            return 1;
-         }
          /* try to avoid loop */
          if (((ntohl(p->server_addr.sin_addr.s_addr) == INADDR_LOOPBACK)
          && p->server_addr.sin_port == config->addr.sin_port )
@@ -2800,7 +2825,7 @@ void parseoptions(int argc, char **argv){
                         rest=line+i+ii+1;
                         if (rest && strlen(rest)>0 ){
                            pargv[pargc][strlen(pargv[pargc])]='=';
-                           memcpy(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
+                           memmove(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
                         }
                      }
                   }
@@ -2873,7 +2898,7 @@ int main(int argc, char ** argv){
    int connfd=0, i=0, cuid=0;
    int abortfd=0;
    struct sockaddr_in  addr;
-   size_t socksize = sizeof(struct sockaddr_in);
+   socklen_t socksize = sizeof(struct sockaddr_in);
    pid_t pid;
    int stat=0;
    FILE * fp;
@@ -2882,12 +2907,12 @@ int main(int argc, char ** argv){
    char * responsemsg;
    int virusdirlen=0;
    char chownit[100];
-#define CHOWNCMD "/bin/chown"
+#define CHOWNCMD "/usr/sbin/chown"
    int len=0;
    int ret=0;
    FILE * chowncmd;
    unsigned long kbfree;
-   struct statvfs fs;
+   struct statfs fs;
 
    w_memory_init();                  // We need to initialize our memory allocation routines
 
@@ -2931,11 +2956,14 @@ int main(int argc, char ** argv){
       do_log(LOG_NOTICE, "Changing uid (we are root)");
       pws = getpwnam(config->runasuser);
       if (pws == NULL) do_log(LOG_EMERG,"ERR: Unknown User '%s'",config->runasuser);
+      if (setgid(pws->pw_gid) != 0) {
+      	do_log(LOG_ERR,"ERR: Cannot setgid() '%s'",pws->pw_gid);
+      }
       setuid(pws->pw_uid);
    }
    cuid=getuid();
    pws = getpwuid(cuid);
-   do_log(LOG_NOTICE, "Running as user: %s",pws->pw_name);
+   do_log(LOG_NOTICE, "Running as user:gid %s:%d",pws->pw_name,pws->pw_gid);
    if (p3signal(SIGCHLD, do_sigchld)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGCHLD");
    if (p3signal(SIGTERM, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGTERM main");
    if (p3signal(SIGINT, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGINT main");
@@ -3036,7 +3064,7 @@ int main(int argc, char ** argv){
       }else{
          /* child */
          config->child=1;
-         if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+         if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
             config->emergency="Unable to get available space!";
             do_log(LOG_EMERG, "ERR: Unable to get available space!");
             return SCANNER_RET_CRIT; // Should never reach here, but keep it clean. :)

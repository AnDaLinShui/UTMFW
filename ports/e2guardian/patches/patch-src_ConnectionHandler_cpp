$ComixWall$
--- src/ConnectionHandler.cpp.orig	Mon Mar 14 17:21:42 2016
+++ src/ConnectionHandler.cpp	Thu Jul 28 00:01:02 2016
@@ -2348,6 +2348,16 @@ int ConnectionHandler::handleConnection(Socket &peerco
                     std::cout << dbgPeerPort << " -header says close, so not persisting" << std::endl;
 #endif
 
+                off_t cl = docheader.contentLength();
+                String temp(docheader.header.front().after(" "));
+                if (cl > 0  && temp.startsWith("304")) {
+                    docbody.in(&proxysock, &peerconn, &header, &docheader, false, &headersent);
+                    docheader.setContentLength(0);
+#ifdef DGDEBUG
+                    std::cout << dbgPeerPort << " -Got 304 body from proxy and discarded it" << std::endl;
+#endif
+                }
+
                 // if we're not careful, we can end up accidentally setting the bypass cookie twice.
                 // because of the code flow, this second cookie ends up with timestamp 0, and is always disallowed.
                 if (isbypass && !isvirusbypass && !iscookiebypass) {
@@ -2380,7 +2390,7 @@ int ConnectionHandler::handleConnection(Socket &peerco
                 // don't even bother scan testing if the content-length header indicates the file is larger than the maximum size we'll scan
                 // - based on patch supplied by cahya (littlecahya@yahoo.de)
                 // be careful: contentLength is signed, and max_content_filecache_scan_size is unsigned
-                off_t cl = docheader.contentLength();
+                cl = docheader.contentLength();
                 if (!responsescanners.empty()) {
                     if (cl == 0)
                         responsescanners.clear();

$OpenBSD$
Index: src/ConnectionHandler.cpp
--- src/ConnectionHandler.cpp.orig
+++ src/ConnectionHandler.cpp
@@ -473,8 +473,13 @@ ConnectionHandler::connectUpstream(Socket &sock, Naugh
         cm.upfailure = false;
         if (cm.isdirect) {
             String des_ip;
-            if (cm.isiphost) {
-                des_ip = cm.urldomain;
+            if (cm.isiphost || !cm.sslproxy_ip.empty()) {
+                if (!cm.sslproxy_ip.empty()) {
+                    des_ip = cm.sslproxy_ip;
+                    port = cm.sslproxy_port;
+                } else {
+                    des_ip = cm.urldomain;
+                }
                 sock.setTimeout(o.connect_timeout);
 #ifdef DGDEBUG
                 std::cerr << thread_id << "Connecting to IPHost " << des_ip << " port " << port << std::endl;
@@ -692,8 +697,9 @@ int ConnectionHandler::handleConnection(Socket &peerco
                     //int pport = peerconn.getPeerSourcePort();
                     std::string peerIP = peerconn.getPeerIP();
 
-                    syslog(LOG_INFO, "%s No header recd from client at %s - errno: %d", thread_id.c_str(),
-                           peerIP.c_str(), err);
+                    // This happens too often, but does not seem to cause any issue, so disable
+                    //syslog(LOG_INFO, "%s No header recd from client at %s - errno: %d", thread_id.c_str(),
+                    //       peerIP.c_str(), err);
 #ifdef DGDEBUG
                     std::cerr << thread_id << " No header recd from client - errno: " << err << std::endl;
 #endif
@@ -781,6 +787,22 @@ int ConnectionHandler::handleConnection(Socket &peerco
 
             }
 //
+            checkme.sslproxy_ip = "";
+            checkme.sslproxy_port = 0;
+            String srcaddrport = header.parseSSLproxyLine();
+            if (!srcaddrport.empty()) {
+                // 127.0.0.1:34649,192.168.3.24:47286,s
+                checkme.sslproxy_ip = srcaddrport.before(":").toCharArray();
+                checkme.sslproxy_port = srcaddrport.after(":").before(",").toInteger();
+                clientip = srcaddrport.after(",").before(":").toCharArray();
+                peerconn.setActualPeerAddrPort(srcaddrport.after(",").before(":").toCharArray(), srcaddrport.after(",").after(":").before(",").toInteger());
+                checkme.is_ssl = (srcaddrport.after(",").after(",") == "s");
+            }
+
+            if (checkme.is_ssl && header.header.front().contains("http://")) {
+                header.header.front() = header.header.front().before("http://") + "https://" + header.header.front().after("http://");
+            }
+
             // do this normalisation etc just the once at the start.
             checkme.setURL(ismitm);
 
@@ -2376,7 +2398,7 @@ bool ConnectionHandler::getdnstxt(std::string &clienti
     // get info from DNS
     union {
         HEADER hdr;
-        u_char buf[NS_PACKETSZ];
+        u_char buf[PACKETSZ];
     } response;
     int responseLen;
     ns_msg handle; /* handle for response message */
@@ -2924,7 +2946,7 @@ bool ConnectionHandler::checkByPass(NaughtyFilter &che
             }
         } else if (ldl->fg[filtergroup]->bypass_mode != 0) {
             if (header.isBypassCookie(checkme.urldomain, ldl->fg[filtergroup]->cookie_magic.c_str(),
-                                      clientip.c_str(), clientuser.c_str())) {
+                                      clientip.c_str(), clientuser.c_str(), ldl->fg[filtergroup]->bypass_v2)) {
 #ifdef DGDEBUG
                 std::cerr << thread_id << " -Bypass cookie match" << std::endl;
 #endif
